---
layout: default
title: Program Transformations
type: Homework
number: 01
active_tab: homework
release_date: 2024-02-04
due_date: 2024-02-08 23:59:00EDT

---

<!-- Check whether the assignment is ready to release -->
{% capture today %}{{'now' | date: '%s'}}{% endcapture %}
{% capture release_date %}{{page.release_date | date: '%s'}}{% endcapture %}
{% if release_date > today %} 
<div class="alert alert-danger">
Warning: this assignment is out of date.  It may still need to be updated for this year's class.  Check with your instructor before you start working on this assignment.
</div>
{% endif %}
<!-- End of check whether the assignment is up to date -->


<!-- Check whether the assignment is up to date -->
{% capture this_year %}{{'now' | date: '%Y'}}{% endcapture %}
{% capture due_year %}{{page.due_date | date: '%Y'}}{% endcapture %}
{% if this_year != due_year %} 
<div class="alert alert-danger">
Warning: this assignment is out of date.  It may still need to be updated for this year's class.  Check with your instructor before you start working on this assignment.
</div>
{% endif %}
<!-- End of check whether the assignment is up to date -->



{% if page.materials %}
<div class="alert alert-info">
You can download the materials for this assignment here:
<ul>
{% for item in page.materials %}
<li><a href="{{item.url}}">{{ item.name }}</a></li>
{% endfor %}
</ul>


<i>Remember to make a copy of the notebook into your own Drive by choosing “Save a Copy in Drive” from Colab’s “File” menu.</i>

</div>
{% endif %}





{{page.type}} {{page.number}}: {{page.title}}
=============================================================

_Due: {{page.due_date}}_

## Overview

In this assignment, you will implement program transformations at two levels:

    - AST (Abstract Syntax Tree) level using the JavaParser library
    - Bytecode level using the ASM library


A program transformation refers to the process of automatically converting a program from one form to another while preserving its intended behavior or semantics. Automatically transorming a program is useful in program optimizations, refactorings, and instrumentation. 

Your task is to manipulate a simple Java program by:

    1. Modifying its AST to add a logging feature.
    2. Modifying its bytecode to optimize method execution by inlining certain methods.

## 1. Bytecode-Level Transformations with ASM

### Warmup: Filling in Missing Bytecode
You will be given a java source file and its corresponding bytecode. Certain portions of the bytecode will be missing, marked with comments like `// PX: missing bytecode`. Your task is to analyze the provided source code and complete the missing bytecode. 

Source:
```java
public class MathExample {
    
    public int multiplyByTwo(int a) {
        return a * 2;
    }

    public int square(int b) {
        return b * b;
    }

    public int getMax(int x, int y) {
        return (x > y) ? x : y;
    }
}
```

Bytecode:
```java
// Method multiplyByTwo
public int multiplyByTwo(int a);
   0: iload_1
   1: iconst_2
   // P1: missing bytecode to multiply a by 2
   2: return

// Method square
public int square(int b);
   0: iload_1
   // P2: missing bytecode to multiply b by b
   1: return

// Method getMax
public int getMax(int x, int y);
   0: iload_1
   1: iload_2
   2: if_icmple  // P3: missing branch target
   3: iload_1
   4: goto       // P4: missing branch target
   5: iload_2
   6: return
```

Mark your answers in a file named `HW1_pt1.txt`.

You can check your answer using the `javap -c` command. 

### Byte Code Transformations

Now that you have a handle on java bytecode, let's write code to perform transformations to it. 

Task: Inline Small Methods

Using the ASM library, you will transform the bytecode of a class to inline any methods that are small enough (e.g., methods that contain only a few bytecode instructions). Inlining is a common optimization that replaces a method call with the body of the method itself, avoiding the overhead of method invocation.
Steps:

    1. Read the bytecode of the compiled Java class using ASM.
    2. Identify methods that are small (less than 5 bytecode instructions).
    3. Replace calls to these small methods with their inlined body in the bytecode.
    4. Write the modified bytecode back to a new .class file.


**Example Input:**
```java
public class Example {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int calculate() {
        return add(2, 3);
    }
}
```

**Expected Bytecode Transformation:**

The method call to add(2, 3) in the calculate method should be replaced by the actual addition operation, avoiding the method call. 

More sample input and outputs to check the correctness of your implementation can be downloaded:
`wget SAMPLES IN A ZIP`

## 2. AST-Level Transformation with JavaParser

**Task: Add Method Logging**

Using the JavaParser library, you will transform a given Java class to add logging at the beginning and end of every method. The logging should print out the method name and the parameters (if any) when the method is invoked.
Steps:

    1. Parse the provided Java source code using JavaParser.
    2. Traverse the AST to locate method declarations.
    3. Inject the following logging code at the beginning and end of each method:

```
System.out.println("Entering method: methodName");
System.out.println("Parameters: " + Arrays.toString(parameters));
// (original method code here)
System.out.println("Exiting method: methodName");
```

Write the modified AST back to the source file.

**Example Input**:
```java
public class Example {
    public int add(int a, int b) {
        return a + b;
    }
}
```

**Expected Output**:
```java
public class Example {
    public int add(int a, int b) {
        System.out.println("Entering method: add");
        System.out.println("Parameters: " + Arrays.toString(new Object[]{a, b}));
        int result = a + b;
        System.out.println("Exiting method: add");
        return result;
    }
}
```

## Submission 

In a text file called `README.txt` answer the following questions:

1. In the bytecode transformation, you inlined small methods. Briefly explain how this improves perfomance. How does this optimization affect other aspects of the program, such as readability, debugging, or maintainability? 
2. In your AST transformation, you added logging statements to each method. How does this transformation affect the performance and readability of the source code? 

Submit your code and README to Gradescope.
